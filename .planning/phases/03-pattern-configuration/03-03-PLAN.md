---
phase: 03-pattern-configuration
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - tests/test_patterns.py
  - tests/conftest.py
autonomous: true

must_haves:
  truths:
    - "Valid pattern configurations pass validation"
    - "Invalid regex patterns rejected with clear errors"
    - "Wrong capture group count rejected with clear errors"
    - "Empty YAML file rejected with clear errors"
    - "PatternConfig integrates correctly with GenericExtractor"
  artifacts:
    - path: "tests/test_patterns.py"
      provides: "Pattern configuration tests"
      min_lines: 80
    - path: "tests/conftest.py"
      provides: "Test fixtures for pattern testing"
      contains: "pattern"
  key_links:
    - from: "tests/test_patterns.py"
      to: "src/cosmograph/config/patterns.py"
      via: "import and test"
      pattern: "from cosmograph.config import"
---

<objective>
Create comprehensive tests for the pattern configuration system.

Purpose: Ensure pattern loading, validation, and integration with GenericExtractor works correctly and handles edge cases gracefully. Tests validate FR-3 acceptance criteria.

Output:
- tests/test_patterns.py with validation and integration tests
- Test fixtures in conftest.py for pattern files
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/STATE.md
@.planning/phases/03-pattern-configuration/03-RESEARCH.md
@.planning/phases/03-pattern-configuration/03-01-SUMMARY.md

@tests/test_extractors.py
@tests/conftest.py
@src/cosmograph/config/patterns.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pattern test fixtures to conftest.py</name>
  <files>tests/conftest.py</files>
  <action>
Add fixtures for creating test pattern YAML files:

1. Add imports at top:
```python
import yaml
```

2. Add fixture for creating valid pattern files:
```python
@pytest.fixture
def create_pattern_file(tmp_path):
    """Factory fixture to create pattern YAML files for testing."""
    def _create(filename: str, config: dict) -> Path:
        filepath = tmp_path / filename
        with open(filepath, 'w') as f:
            yaml.dump(config, f)
        return filepath
    return _create

@pytest.fixture
def valid_pattern_config():
    """Return a valid pattern configuration dict."""
    return {
        'version': '1.0',
        'name': 'test-patterns',
        'description': 'Test patterns',
        'min_occurrences': 1,
        'entity_patterns': [
            {
                'name': 'email',
                'pattern': r'([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})',
                'category': 'email',
                'description': 'Email addresses',
                'min_length': 5
            },
            {
                'name': 'phone',
                'pattern': r'(\d{3}-\d{3}-\d{4})',
                'category': 'phone',
                'description': 'US phone numbers'
            }
        ],
        'relationship_triggers': [
            {
                'name': 'mentions',
                'source_categories': ['document'],
                'target_categories': ['email', 'phone'],
                'proximity': 0
            }
        ]
    }
```

Keep existing fixtures for PDF tests unchanged.
  </action>
  <verify>
pytest tests/conftest.py --collect-only 2>&1 | grep -q "create_pattern_file"
  </verify>
  <done>
Pattern test fixtures added to conftest.py, pytest discovers them.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test_patterns.py with validation tests</name>
  <files>tests/test_patterns.py</files>
  <action>
Create comprehensive test file for pattern configuration:

```python
"""Unit tests for pattern configuration."""

import pytest
from pathlib import Path
from pydantic import ValidationError

from cosmograph.config import (
    PatternConfig,
    EntityPattern,
    RelationshipTrigger,
    load_patterns,
    load_default_patterns,
)
from cosmograph.extractors import GenericExtractor
from cosmograph.models import Graph


class TestEntityPattern:
    """Tests for EntityPattern model validation."""

    def test_valid_pattern_with_one_capture_group(self):
        """Pattern with exactly one capture group should pass."""
        ep = EntityPattern(
            name="test",
            pattern=r"([a-z]+)",
            category="test"
        )
        assert ep.name == "test"
        assert ep.pattern == r"([a-z]+)"

    def test_invalid_regex_syntax(self):
        """Pattern with invalid regex syntax should fail."""
        with pytest.raises(ValidationError) as exc_info:
            EntityPattern(name="bad", pattern=r"[", category="test")
        assert "Invalid regex" in str(exc_info.value)

    def test_zero_capture_groups(self):
        """Pattern with no capture groups should fail."""
        with pytest.raises(ValidationError) as exc_info:
            EntityPattern(name="no_group", pattern=r"[a-z]+", category="test")
        assert "capture group" in str(exc_info.value).lower()

    def test_multiple_capture_groups(self):
        """Pattern with multiple capture groups should fail."""
        with pytest.raises(ValidationError) as exc_info:
            EntityPattern(name="multi", pattern=r"([a-z]+)([0-9]+)", category="test")
        assert "capture group" in str(exc_info.value).lower()

    def test_non_capturing_groups_allowed(self):
        """Non-capturing groups (?:...) should not count."""
        ep = EntityPattern(
            name="with_non_capturing",
            pattern=r"(?:Mr|Mrs)\s+([A-Z][a-z]+)",
            category="person"
        )
        assert ep.pattern == r"(?:Mr|Mrs)\s+([A-Z][a-z]+)"

    def test_default_values(self):
        """Default values should be applied."""
        ep = EntityPattern(name="test", pattern=r"([a-z]+)", category="test")
        assert ep.description == ""
        assert ep.min_length == 2


class TestRelationshipTrigger:
    """Tests for RelationshipTrigger model."""

    def test_valid_trigger(self):
        rt = RelationshipTrigger(
            name="mentions",
            source_categories=["document"],
            target_categories=["entity"]
        )
        assert rt.proximity == 0
        assert rt.trigger_pattern is None

    def test_with_trigger_pattern(self):
        rt = RelationshipTrigger(
            name="defines",
            source_categories=["section"],
            target_categories=["term"],
            trigger_pattern=r"means|shall mean"
        )
        assert rt.trigger_pattern == r"means|shall mean"


class TestPatternConfig:
    """Tests for PatternConfig model."""

    def test_valid_config(self, valid_pattern_config):
        config = PatternConfig.model_validate(valid_pattern_config)
        assert config.version == "1.0"
        assert len(config.entity_patterns) == 2
        assert len(config.relationship_triggers) == 1

    def test_minimal_config(self):
        """Minimal config with just required fields."""
        config = PatternConfig.model_validate({
            'entity_patterns': [
                {'name': 'test', 'pattern': r'([a-z]+)', 'category': 'test'}
            ]
        })
        assert config.version == "1.0"
        assert config.min_occurrences == 2
        assert config.relationship_triggers == []

    def test_empty_entity_patterns_fails(self):
        """Config with empty entity_patterns should fail."""
        with pytest.raises(ValidationError):
            PatternConfig.model_validate({'entity_patterns': []})


class TestLoadPatterns:
    """Tests for load_patterns function."""

    def test_load_valid_file(self, create_pattern_file, valid_pattern_config):
        filepath = create_pattern_file("valid.yaml", valid_pattern_config)
        config = load_patterns(filepath)
        assert config.name == "test-patterns"
        assert len(config.entity_patterns) == 2

    def test_load_invalid_yaml_syntax(self, tmp_path):
        """Invalid YAML syntax should raise ValueError."""
        filepath = tmp_path / "invalid.yaml"
        filepath.write_text("{ unclosed: bracket")
        with pytest.raises(ValueError) as exc_info:
            load_patterns(filepath)
        assert "Invalid YAML" in str(exc_info.value)

    def test_load_empty_file(self, tmp_path):
        """Empty file should raise ValueError."""
        filepath = tmp_path / "empty.yaml"
        filepath.write_text("")
        with pytest.raises(ValueError) as exc_info:
            load_patterns(filepath)
        assert "Empty" in str(exc_info.value)

    def test_load_invalid_pattern_in_file(self, create_pattern_file):
        """File with invalid regex should raise ValidationError."""
        config = {
            'entity_patterns': [
                {'name': 'bad', 'pattern': '[invalid', 'category': 'test'}
            ]
        }
        filepath = create_pattern_file("bad_regex.yaml", config)
        with pytest.raises(ValidationError):
            load_patterns(filepath)


class TestLoadDefaultPatterns:
    """Tests for load_default_patterns function."""

    def test_loads_successfully(self):
        config = load_default_patterns()
        assert isinstance(config, PatternConfig)
        assert config.name == "default"

    def test_has_expected_patterns(self):
        config = load_default_patterns()
        pattern_names = {ep.name for ep in config.entity_patterns}
        assert "proper_noun" in pattern_names
        assert "acronym" in pattern_names
        assert "quoted_term" in pattern_names
        assert "section_ref" in pattern_names

    def test_patterns_are_valid_regex(self):
        """All default patterns should be valid."""
        import re
        config = load_default_patterns()
        for ep in config.entity_patterns:
            compiled = re.compile(ep.pattern)
            assert compiled.groups == 1


class TestGenericExtractorWithConfig:
    """Tests for GenericExtractor with PatternConfig."""

    def test_extracts_with_custom_patterns(self, tmp_path, create_pattern_file, valid_pattern_config):
        # Create test document
        doc = tmp_path / "test.txt"
        doc.write_text("Contact us at test@example.com or call 555-123-4567.")

        # Load config
        config_path = create_pattern_file("patterns.yaml", valid_pattern_config)
        from cosmograph.config import load_patterns
        config = load_patterns(config_path)

        # Extract
        extractor = GenericExtractor(config=config)
        graph = extractor.extract(doc)

        # Should find email and phone
        labels = [n.label for n in graph.nodes.values()]
        assert any("test@example.com" in label for label in labels)
        assert any("555-123-4567" in label for label in labels)

    def test_respects_config_min_occurrences(self, tmp_path):
        config = PatternConfig.model_validate({
            'min_occurrences': 3,
            'entity_patterns': [
                {'name': 'word', 'pattern': r'\b([A-Z][a-z]+)\b', 'category': 'word'}
            ]
        })

        doc = tmp_path / "test.txt"
        doc.write_text("Alpha Beta Alpha Alpha Gamma")

        extractor = GenericExtractor(config=config)
        graph = extractor.extract(doc)

        labels = [n.label for n in graph.nodes.values()]
        # Alpha appears 3 times, should be included
        assert any("Alpha" in label for label in labels)
        # Beta and Gamma appear less than 3 times, should not be included
        assert not any(label == "Beta" for label in labels)
        assert not any(label == "Gamma" for label in labels)

    def test_uses_pattern_category(self, tmp_path):
        config = PatternConfig.model_validate({
            'min_occurrences': 1,
            'entity_patterns': [
                {'name': 'email', 'pattern': r'([a-z]+@[a-z]+\.com)', 'category': 'contact_email'}
            ]
        })

        doc = tmp_path / "test.txt"
        doc.write_text("Email me at test@example.com")

        extractor = GenericExtractor(config=config)
        graph = extractor.extract(doc)

        # Find the email node
        email_nodes = [n for n in graph.nodes.values() if "test@example.com" in n.label]
        assert len(email_nodes) == 1
        assert email_nodes[0].category == "contact_email"
```

Note: Test class TestPatternConfig.test_empty_entity_patterns_fails may need adjustment based on whether empty patterns are allowed (consider removing if not a requirement).
  </action>
  <verify>
pytest tests/test_patterns.py -v --tb=short
  </verify>
  <done>
All pattern tests pass, covering validation, loading, error handling, and GenericExtractor integration.
  </done>
</task>

</tasks>

<verification>
1. Run full test suite: `pytest -v`
2. Check test coverage: `pytest --cov=src/cosmograph/config tests/test_patterns.py`
3. Verify no regressions: `pytest tests/test_extractors.py -v`
4. Run linter: `ruff check tests/test_patterns.py`
</verification>

<success_criteria>
- test_patterns.py exists with at least 15 test functions
- All tests pass
- Tests cover: valid patterns, invalid regex, wrong capture groups, empty files, YAML errors
- Tests verify GenericExtractor integration with PatternConfig
- Existing extractor tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/03-pattern-configuration/03-03-SUMMARY.md`
</output>
