---
phase: 06-react-frontend
plan: 03
type: execute
wave: 3
depends_on: [06-02]
files_modified:
  - frontend/src/hooks/useExtraction.ts
  - frontend/src/hooks/useProgress.ts
  - frontend/src/components/ProgressDisplay.tsx
  - frontend/src/components/ProgressDisplay.css
  - frontend/src/components/GraphPreview.tsx
  - frontend/src/components/GraphPreview.css
  - frontend/src/components/DownloadButtons.tsx
  - frontend/src/components/DownloadButtons.css
  - frontend/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Progress bar updates during file processing"
    - "SSE connection streams real-time progress"
    - "Graph displays in iframe after extraction completes"
    - "User can download HTML visualization"
    - "User can download CSV archive"
  artifacts:
    - path: "frontend/src/hooks/useProgress.ts"
      provides: "SSE progress streaming hook"
      min_lines: 40
    - path: "frontend/src/hooks/useExtraction.ts"
      provides: "Extraction workflow orchestration hook"
      min_lines: 50
    - path: "frontend/src/components/ProgressDisplay.tsx"
      provides: "Progress bar component"
      min_lines: 25
    - path: "frontend/src/components/GraphPreview.tsx"
      provides: "Iframe graph visualization"
      min_lines: 15
    - path: "frontend/src/components/DownloadButtons.tsx"
      provides: "HTML and CSV download buttons"
      min_lines: 20
  key_links:
    - from: "frontend/src/hooks/useProgress.ts"
      to: "/api/extract/{id}/progress"
      via: "EventSource SSE connection"
      pattern: "EventSource.*progress"
    - from: "frontend/src/components/GraphPreview.tsx"
      to: "/api/download/{id}"
      via: "iframe src"
      pattern: "iframe.*download"
    - from: "frontend/src/hooks/useExtraction.ts"
      to: "frontend/src/services/api.ts"
      via: "createExtraction call"
      pattern: "createExtraction"
---

<objective>
Implement extraction workflow with real-time progress display, graph preview, and downloads.

Purpose: Complete the extraction flow from file submission through results display.
Output: Full extraction workflow with SSE progress, iframe graph display, and download buttons.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v0.2.0/ROADMAP.md
@.planning/phases/06-react-frontend/06-RESEARCH.md
@frontend/src/services/api.ts
@frontend/src/types/index.ts
@src/cosmograph/api/routes/extract.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create progress and extraction hooks</name>
  <files>
    frontend/src/hooks/useProgress.ts
    frontend/src/hooks/useExtraction.ts
  </files>
  <action>
Create hooks directory and useProgress.ts for SSE streaming:

```typescript
// frontend/src/hooks/useProgress.ts
import { useEffect, useState, useCallback } from 'react';
import type { JobStatus } from '../types';

interface ProgressState {
  status: JobStatus;
  progress: number;
  total: number;
  isComplete: boolean;
  error: string | null;
}

const initialState: ProgressState = {
  status: 'pending',
  progress: 0,
  total: 0,
  isComplete: false,
  error: null,
};

/**
 * Hook to stream extraction progress via Server-Sent Events.
 *
 * Connects to /api/extract/{jobId}/progress and receives progress, complete, and error events.
 * Automatically closes connection when job completes or fails.
 */
export function useProgress(jobId: string | null) {
  const [state, setState] = useState<ProgressState>(initialState);

  const reset = useCallback(() => {
    setState(initialState);
  }, []);

  useEffect(() => {
    if (!jobId) {
      reset();
      return;
    }

    const eventSource = new EventSource(`/api/extract/${jobId}/progress`);

    eventSource.addEventListener('progress', (event) => {
      try {
        const data = JSON.parse(event.data);
        setState(prev => ({
          ...prev,
          status: data.status,
          progress: data.progress,
          total: data.total,
        }));
      } catch (e) {
        console.error('Failed to parse progress event:', e);
      }
    });

    eventSource.addEventListener('complete', () => {
      setState(prev => ({ ...prev, status: 'completed', isComplete: true }));
      eventSource.close();
    });

    eventSource.addEventListener('error', (event) => {
      // Check if it's a data event (server-sent error) vs connection error
      if (event instanceof MessageEvent && event.data) {
        try {
          const data = JSON.parse(event.data);
          setState(prev => ({ ...prev, status: 'failed', error: data.error }));
        } catch (e) {
          setState(prev => ({ ...prev, status: 'failed', error: 'Unknown error occurred' }));
        }
      }
      eventSource.close();
    });

    // Connection error handler (network issues, server down)
    eventSource.onerror = () => {
      // EventSource auto-reconnects on some errors; only close if readyState is CLOSED
      if (eventSource.readyState === EventSource.CLOSED) {
        setState(prev => ({
          ...prev,
          status: 'failed',
          error: 'Connection lost. Please try again.',
        }));
      }
    };

    // Cleanup on unmount or jobId change
    return () => {
      eventSource.close();
    };
  }, [jobId, reset]);

  return { ...state, reset };
}
```

Create useExtraction.ts to orchestrate the full extraction workflow:

```typescript
// frontend/src/hooks/useExtraction.ts
import { useState, useCallback } from 'react';
import { createExtraction, ApiError } from '../services/api';
import { useProgress } from './useProgress';
import type { ExtractionOptions } from '../types';

type ExtractionState = 'idle' | 'uploading' | 'processing' | 'completed' | 'failed';

interface UseExtractionResult {
  state: ExtractionState;
  jobId: string | null;
  progress: number;
  total: number;
  error: string | null;
  startExtraction: (files: File[], options: ExtractionOptions) => Promise<void>;
  reset: () => void;
}

/**
 * Hook to manage the full extraction workflow.
 *
 * Handles: file upload -> job creation -> progress tracking -> completion.
 */
export function useExtraction(): UseExtractionResult {
  const [state, setState] = useState<ExtractionState>('idle');
  const [jobId, setJobId] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);

  const progressData = useProgress(jobId);

  // Sync progress state to extraction state
  const derivedState = (): ExtractionState => {
    if (state === 'uploading') return 'uploading';
    if (progressData.isComplete) return 'completed';
    if (progressData.error || state === 'failed') return 'failed';
    if (jobId && progressData.status === 'processing') return 'processing';
    if (jobId && progressData.status === 'pending') return 'processing';
    return state;
  };

  const startExtraction = useCallback(async (files: File[], options: ExtractionOptions) => {
    // Reset previous state
    setError(null);
    setJobId(null);
    progressData.reset();
    setState('uploading');

    try {
      const response = await createExtraction(
        files,
        options.extractor,
        options.title,
        options.llmConfirmed
      );

      setJobId(response.job_id);
      setState('processing');
    } catch (e) {
      setState('failed');
      if (e instanceof ApiError) {
        setError(e.message);
      } else if (e instanceof Error) {
        setError(e.message);
      } else {
        setError('An unexpected error occurred');
      }
    }
  }, [progressData]);

  const reset = useCallback(() => {
    setState('idle');
    setJobId(null);
    setError(null);
    progressData.reset();
  }, [progressData]);

  return {
    state: derivedState(),
    jobId,
    progress: progressData.progress,
    total: progressData.total,
    error: error || progressData.error,
    startExtraction,
    reset,
  };
}
```
  </action>
  <verify>
`cd frontend && npx tsc --noEmit` passes.
Hooks export correctly and types align.
  </verify>
  <done>useProgress and useExtraction hooks for SSE streaming and workflow orchestration</done>
</task>

<task type="auto">
  <name>Task 2: Create progress, graph preview, and download components</name>
  <files>
    frontend/src/components/ProgressDisplay.tsx
    frontend/src/components/ProgressDisplay.css
    frontend/src/components/GraphPreview.tsx
    frontend/src/components/GraphPreview.css
    frontend/src/components/DownloadButtons.tsx
    frontend/src/components/DownloadButtons.css
  </files>
  <action>
Create ProgressDisplay.tsx:

```tsx
// frontend/src/components/ProgressDisplay.tsx
import './ProgressDisplay.css';

interface ProgressDisplayProps {
  status: string;
  progress: number;
  total: number;
}

export function ProgressDisplay({ status, progress, total }: ProgressDisplayProps) {
  const percent = total > 0 ? Math.round((progress / total) * 100) : 0;

  const getStatusText = () => {
    switch (status) {
      case 'pending':
        return 'Preparing...';
      case 'processing':
        return `Processing file ${progress} of ${total}`;
      case 'completed':
        return 'Extraction complete!';
      case 'failed':
        return 'Extraction failed';
      default:
        return status;
    }
  };

  return (
    <div className="progress-display">
      <div className="progress-header">
        <span className="progress-status">{getStatusText()}</span>
        <span className="progress-percent">{percent}%</span>
      </div>
      <div className="progress-bar">
        <div
          className={`progress-fill ${status === 'completed' ? 'complete' : ''} ${status === 'failed' ? 'failed' : ''}`}
          style={{ width: `${percent}%` }}
        />
      </div>
    </div>
  );
}
```

Create ProgressDisplay.css:

```css
/* frontend/src/components/ProgressDisplay.css */
.progress-display {
  margin-bottom: 20px;
}

.progress-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 8px;
  font-size: 14px;
}

.progress-status {
  color: #ccc;
}

.progress-percent {
  color: #4fc3f7;
  font-weight: 500;
}

.progress-bar {
  width: 100%;
  height: 8px;
  background: #333;
  border-radius: 4px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: #4fc3f7;
  transition: width 0.3s ease;
}

.progress-fill.complete {
  background: #66bb6a;
}

.progress-fill.failed {
  background: #ef5350;
}
```

Create GraphPreview.tsx:

```tsx
// frontend/src/components/GraphPreview.tsx
import './GraphPreview.css';

interface GraphPreviewProps {
  jobId: string;
}

/**
 * Display the generated graph visualization in an iframe.
 *
 * Uses the self-contained HTML from the download endpoint.
 * The HTML includes embedded D3.js and all data - no additional loading needed.
 */
export function GraphPreview({ jobId }: GraphPreviewProps) {
  const htmlUrl = `/api/download/${jobId}`;

  return (
    <div className="graph-preview">
      <iframe
        src={htmlUrl}
        title="Knowledge Graph Visualization"
        sandbox="allow-scripts"
      />
    </div>
  );
}
```

Create GraphPreview.css:

```css
/* frontend/src/components/GraphPreview.css */
.graph-preview {
  width: 100%;
  height: 500px;
  border: 1px solid #333;
  border-radius: 8px;
  overflow: hidden;
  background: #1a1a1a;
}

.graph-preview iframe {
  width: 100%;
  height: 100%;
  border: none;
}
```

Create DownloadButtons.tsx:

```tsx
// frontend/src/components/DownloadButtons.tsx
import { getDownloadHtmlUrl, getDownloadCsvUrl } from '../services/api';
import './DownloadButtons.css';

interface DownloadButtonsProps {
  jobId: string;
}

export function DownloadButtons({ jobId }: DownloadButtonsProps) {
  const htmlUrl = getDownloadHtmlUrl(jobId);
  const csvUrl = getDownloadCsvUrl(jobId);

  return (
    <div className="download-buttons">
      <a href={htmlUrl} download className="btn-download btn-html">
        Download HTML
      </a>
      <a href={csvUrl} download className="btn-download btn-csv">
        Download CSV
      </a>
    </div>
  );
}
```

Create DownloadButtons.css:

```css
/* frontend/src/components/DownloadButtons.css */
.download-buttons {
  display: flex;
  gap: 12px;
  margin-top: 16px;
}

.btn-download {
  flex: 1;
  padding: 12px 20px;
  text-align: center;
  text-decoration: none;
  font-size: 14px;
  font-weight: 500;
  border-radius: 6px;
  transition: background 0.2s;
}

.btn-html {
  background: #4fc3f7;
  color: #000;
}

.btn-html:hover {
  background: #29b6f6;
}

.btn-csv {
  background: #444;
  color: #fff;
}

.btn-csv:hover {
  background: #555;
}
```
  </action>
  <verify>
`cd frontend && npx tsc --noEmit` passes.
Components export correctly.
  </verify>
  <done>ProgressDisplay, GraphPreview, and DownloadButtons components</done>
</task>

<task type="auto">
  <name>Task 3: Integrate extraction workflow into App</name>
  <files>
    frontend/src/App.tsx
    frontend/src/App.css
  </files>
  <action>
Update App.tsx to use extraction hooks and display results:

```tsx
// frontend/src/App.tsx
import { useState } from 'react';
import { FileUpload } from './components/FileUpload';
import { ExtractionOptions } from './components/ExtractionOptions';
import { ProgressDisplay } from './components/ProgressDisplay';
import { GraphPreview } from './components/GraphPreview';
import { DownloadButtons } from './components/DownloadButtons';
import { useExtraction } from './hooks/useExtraction';
import type { ExtractionOptions as Options } from './types';
import './App.css';

function App() {
  const [files, setFiles] = useState<File[]>([]);
  const [options, setOptions] = useState<Options>({
    extractor: 'auto',
    title: 'Knowledge Graph',
    llmConfirmed: false,
  });

  const extraction = useExtraction();

  const isProcessing = extraction.state === 'uploading' || extraction.state === 'processing';
  const isComplete = extraction.state === 'completed';
  const isFailed = extraction.state === 'failed';
  const canStartExtraction = files.length > 0 && !isProcessing;

  const handleStartExtraction = async () => {
    await extraction.startExtraction(files, options);
  };

  const handleNewExtraction = () => {
    setFiles([]);
    setOptions({
      extractor: 'auto',
      title: 'Knowledge Graph',
      llmConfirmed: false,
    });
    extraction.reset();
  };

  return (
    <div className="app">
      <header className="app-header">
        <h1>Cosmograph</h1>
        <p>Document-to-Knowledge-Graph Service</p>
      </header>

      <main className="app-main">
        {/* Show upload UI when idle or failed */}
        {(extraction.state === 'idle' || isFailed) && (
          <>
            <section className="upload-section">
              <h2>1. Select Files</h2>
              <FileUpload
                onFilesSelected={setFiles}
                selectedFiles={files}
                disabled={isProcessing}
              />
            </section>

            <section className="options-section">
              <h2>2. Configure Extraction</h2>
              <ExtractionOptions
                options={options}
                onChange={setOptions}
                disabled={isProcessing}
              />
            </section>

            {isFailed && extraction.error && (
              <section className="error-section">
                <div className="error-message">
                  <strong>Error:</strong> {extraction.error}
                </div>
              </section>
            )}

            <section className="action-section">
              <button
                type="button"
                className="btn-extract"
                onClick={handleStartExtraction}
                disabled={!canStartExtraction}
              >
                Start Extraction
              </button>
            </section>
          </>
        )}

        {/* Show progress during processing */}
        {isProcessing && (
          <section className="progress-section">
            <h2>Processing...</h2>
            <ProgressDisplay
              status={extraction.state === 'uploading' ? 'uploading' : 'processing'}
              progress={extraction.progress}
              total={extraction.total}
            />
            {extraction.state === 'uploading' && (
              <p className="uploading-text">Uploading files...</p>
            )}
          </section>
        )}

        {/* Show results when complete */}
        {isComplete && extraction.jobId && (
          <section className="results-section">
            <div className="results-header">
              <h2>Results</h2>
              <button
                type="button"
                className="btn-new-extraction"
                onClick={handleNewExtraction}
              >
                New Extraction
              </button>
            </div>

            <GraphPreview jobId={extraction.jobId} />
            <DownloadButtons jobId={extraction.jobId} />
          </section>
        )}
      </main>
    </div>
  );
}

export default App;
```

Add additional styles to App.css:

```css
/* frontend/src/App.css */
* {
  box-sizing: border-box;
}

body {
  margin: 0;
  background: #121212;
  color: #fff;
}

.app {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
  font-family: system-ui, -apple-system, sans-serif;
}

.app-header {
  margin-bottom: 32px;
  padding-bottom: 16px;
  border-bottom: 1px solid #333;
}

.app-header h1 {
  margin: 0 0 4px;
  font-size: 28px;
  color: #4fc3f7;
}

.app-header p {
  margin: 0;
  color: #888;
  font-size: 14px;
}

.app-main {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

section h2 {
  margin: 0 0 12px;
  font-size: 16px;
  font-weight: 500;
  color: #aaa;
}

.action-section {
  padding-top: 8px;
}

.btn-extract {
  width: 100%;
  padding: 14px 24px;
  font-size: 16px;
  font-weight: 500;
  background: #4fc3f7;
  border: none;
  border-radius: 6px;
  color: #000;
  cursor: pointer;
  transition: background 0.2s;
}

.btn-extract:hover:not(:disabled) {
  background: #29b6f6;
}

.btn-extract:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Error display */
.error-section {
  margin-top: -8px;
}

.error-message {
  padding: 12px 16px;
  background: rgba(239, 83, 80, 0.1);
  border: 1px solid #ef5350;
  border-radius: 6px;
  color: #ef5350;
  font-size: 14px;
}

/* Progress section */
.progress-section {
  padding: 24px;
  background: #1a1a1a;
  border-radius: 8px;
}

.uploading-text {
  margin: 12px 0 0;
  color: #888;
  font-size: 14px;
  text-align: center;
}

/* Results section */
.results-section {
  padding: 20px;
  background: #1a1a1a;
  border-radius: 8px;
}

.results-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.results-header h2 {
  margin: 0;
}

.btn-new-extraction {
  padding: 8px 16px;
  font-size: 14px;
  background: #333;
  border: none;
  border-radius: 4px;
  color: #ccc;
  cursor: pointer;
}

.btn-new-extraction:hover {
  background: #444;
}
```
  </action>
  <verify>
1. `cd frontend && npm run dev` - starts without errors
2. Start backend: `cd /Users/guthdx/terminal_projects/cosmograph && source .venv/bin/activate && uvicorn cosmograph.api.main:app --reload`
3. Upload a test file through the UI
4. Progress bar updates during processing
5. Graph displays in iframe after completion
6. Download buttons work (HTML and CSV)
7. "New Extraction" resets the UI
  </verify>
  <done>Complete extraction workflow with progress, graph preview, and downloads integrated</done>
</task>

</tasks>

<verification>
1. `cd frontend && npx tsc --noEmit` passes (no type errors)
2. With backend running, full extraction flow works:
   - Upload file(s)
   - Progress bar shows file-by-file progress via SSE
   - Graph displays in iframe after completion
   - Download HTML button downloads visualization
   - Download CSV button downloads ZIP archive
3. Error states display correctly (try invalid file or network error)
4. "New Extraction" button resets to initial state
</verification>

<success_criteria>
- SSE progress streaming works via useProgress hook
- Progress bar updates in real-time during extraction
- Graph visualization displays in iframe
- HTML download works
- CSV download works
- Error states display appropriately
- New Extraction resets the workflow
</success_criteria>

<output>
After completion, create `.planning/phases/06-react-frontend/06-03-SUMMARY.md`
</output>
