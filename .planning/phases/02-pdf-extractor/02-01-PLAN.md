---
phase: 02-pdf-extractor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cosmograph/extractors/pdf.py
  - src/cosmograph/extractors/__init__.py
autonomous: true

must_haves:
  truths:
    - "Valid PDFs produce entity graphs with document nodes and extracted entities"
    - "Encrypted PDFs fail with clear 'password-protected' error message"
    - "Scanned PDFs (image-only) fail with clear 'scanned' error message"
    - "Multi-page PDFs produce content in correct reading order (page 1 before page 2)"
  artifacts:
    - path: "src/cosmograph/extractors/pdf.py"
      provides: "PdfExtractor class inheriting BaseExtractor"
      min_lines: 60
      exports: ["PdfExtractor"]
    - path: "src/cosmograph/extractors/__init__.py"
      provides: "Module exports including PdfExtractor"
      contains: "PdfExtractor"
  key_links:
    - from: "src/cosmograph/extractors/pdf.py"
      to: "src/cosmograph/extractors/base.py"
      via: "class inheritance"
      pattern: "class PdfExtractor\\(BaseExtractor\\)"
    - from: "src/cosmograph/extractors/pdf.py"
      to: "src/cosmograph/extractors/legal.py"
      via: "temp file delegation - writes extracted text to temp file, calls LegalDocumentExtractor.extract(temp_path)"
      pattern: "LegalDocumentExtractor.*\\.extract\\("
---

<objective>
Create PdfExtractor class that extracts entities from PDF documents.

Purpose: Enable PDF document processing to satisfy FR-1 requirements. PDFs are the most common client document format.

Output: Working `PdfExtractor` class that handles text extraction, error cases (encrypted/scanned), and delegates entity extraction to LegalDocumentExtractor via temp file.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-pdf-extractor/02-RESEARCH.md
@src/cosmograph/extractors/base.py
@src/cosmograph/extractors/legal.py
@src/cosmograph/extractors/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PdfExtractor class</name>
  <files>src/cosmograph/extractors/pdf.py</files>
  <action>
Create `src/cosmograph/extractors/pdf.py` with PdfExtractor class:

1. Imports:
   ```python
   import tempfile
   from pathlib import Path
   import pymupdf  # NOT fitz - that's the legacy name
   from .base import BaseExtractor
   from .legal import LegalDocumentExtractor
   ```

2. Inherit from `BaseExtractor`

3. Implement `supports()` - return True for `.pdf` suffix (case insensitive)

4. Implement `extract()` using temp file delegation pattern:
   ```python
   def extract(self, filepath: Path) -> Graph:
       """Extract entities from a PDF document via LegalDocumentExtractor."""
       doc = None
       try:
           doc = pymupdf.open(filepath)

           # Check for encrypted PDF
           if doc.needs_pass:
               raise ValueError(f"PDF is password-protected: {filepath.name}")

           # Extract text from all pages with reading order preserved
           text_parts = []
           for page in doc:
               text_parts.append(page.get_text(sort=True))
           full_text = "\n".join(text_parts)

           # Check for scanned PDF (no extractable text)
           if self._is_likely_scanned(doc, full_text):
               raise ValueError(f"PDF appears to be scanned (no extractable text): {filepath.name}")

           # Delegate to LegalDocumentExtractor via temp file
           # LegalDocumentExtractor.extract() expects a filepath, not raw text
           with tempfile.NamedTemporaryFile(
               mode='w',
               suffix='.txt',
               prefix=filepath.stem + '_',
               delete=False,
               encoding='utf-8'
           ) as tmp:
               tmp.write(full_text)
               tmp_path = Path(tmp.name)

           try:
               # Use same graph instance for continuity
               legal_extractor = LegalDocumentExtractor(self.graph)
               return legal_extractor.extract(tmp_path)
           finally:
               # Clean up temp file
               tmp_path.unlink(missing_ok=True)

       finally:
           if doc:
               doc.close()
   ```

5. Implement `_is_likely_scanned()` heuristic:
   ```python
   def _is_likely_scanned(self, doc, text: str) -> bool:
       """Detect if PDF is likely a scanned document (image-only)."""
       # If we have substantial text, it's not scanned
       if len(text.strip()) > 100:
           return False

       # Check for pages with images but minimal text
       for page in doc:
           # Get image count on page
           images = page.get_images()
           page_text = page.get_text().strip()
           # Full-page image with < 50 chars suggests scanned
           if images and len(page_text) < 50:
               return True

       # Very little text overall suggests scanned
       return len(text.strip()) < 20
   ```

Key patterns from research:
- Use `for page in doc:` iterator (not index-based)
- Use `sort=True` parameter for reading order
- Use try/finally to ensure doc.close()
- Temp file preserves the original filename stem for better document node naming

Error messages should be user-friendly:
- Encrypted: "PDF is password-protected: {filename}"
- Scanned: "PDF appears to be scanned (no extractable text): {filename}"
  </action>
  <verify>
```bash
# Verify file exists and has correct structure
python -c "from cosmograph.extractors.pdf import PdfExtractor; print('Import OK')"
python -c "from cosmograph.extractors.pdf import PdfExtractor; e = PdfExtractor(); print(f'supports .pdf: {e.supports(__import__(\"pathlib\").Path(\"test.pdf\"))}')"
# Verify temp file delegation pattern is present
grep -q "tempfile" src/cosmograph/extractors/pdf.py && grep -q "LegalDocumentExtractor" src/cosmograph/extractors/pdf.py && echo "Delegation pattern OK"
```
  </verify>
  <done>PdfExtractor class exists with supports(), extract() using temp file delegation, and _is_likely_scanned() methods</done>
</task>

<task type="auto">
  <name>Task 2: Export PdfExtractor from module</name>
  <files>src/cosmograph/extractors/__init__.py</files>
  <action>
Update `src/cosmograph/extractors/__init__.py`:

1. Add import: `from .pdf import PdfExtractor`
2. Add `PdfExtractor` to `__all__` list

Maintain alphabetical ordering of imports and exports.
  </action>
  <verify>
```bash
python -c "from cosmograph.extractors import PdfExtractor; print('Module export OK')"
```
  </verify>
  <done>PdfExtractor is importable from cosmograph.extractors package</done>
</task>

</tasks>

<verification>
```bash
# Verify complete integration
python -c "
from cosmograph.extractors import PdfExtractor, BaseExtractor
from pathlib import Path

# Check inheritance
assert issubclass(PdfExtractor, BaseExtractor), 'Must inherit BaseExtractor'

# Check methods exist
e = PdfExtractor()
assert hasattr(e, 'supports'), 'Missing supports method'
assert hasattr(e, 'extract'), 'Missing extract method'
assert hasattr(e, '_is_likely_scanned'), 'Missing scanned detection'

# Check file support
assert e.supports(Path('doc.pdf')), 'Should support .pdf'
assert not e.supports(Path('doc.txt')), 'Should not support .txt'

print('All verification checks passed')
"
```
</verification>

<success_criteria>
- PdfExtractor class exists in src/cosmograph/extractors/pdf.py
- Class properly inherits from BaseExtractor
- supports() returns True for .pdf files only
- extract() uses temp file delegation to LegalDocumentExtractor (not direct method calls)
- extract() handles: valid PDFs, encrypted PDFs (ValueError), scanned PDFs (ValueError)
- PdfExtractor importable from cosmograph.extractors
- Code follows project conventions (type hints, docstrings, ruff-compliant)
</success_criteria>

<output>
After completion, create `.planning/phases/02-pdf-extractor/02-01-SUMMARY.md`
</output>
